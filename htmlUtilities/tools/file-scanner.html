<!DOCTYPE html>
<html lang="sk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraktor projektov√Ωch s√∫borov pre AI</title>
    <style>
        :root {
            --primary-color: #4a6da7;
            --secondary-color: #5a7db7;
            --accent-color: #3c5a8c;
            --text-color: #333;
            --background-color: #f5f5f5;
            --border-color: #ddd;
            --hover-color: #f0f0f0;
            --selected-color: #e6f0ff;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--background-color);
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
        }

        header {
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 20px;
        }

        h1 {
            color: var(--primary-color);
            margin-bottom: 10px;
        }

        h2 {
            color: var(--secondary-color);
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        section {
            margin-bottom: 30px;
        }

        .file-selector {
            margin-bottom: 20px;
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: var(--accent-color);
        }

        button:disabled {
            background-color: var(--border-color);
            cursor: not-allowed;
        }

        #selected-dir-path {
            padding: 8px;
            background-color: var(--hover-color);
            border-radius: 4px;
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .stats-panel, .extensions-panel {
            background-color: var(--hover-color);
            border-radius: 6px;
            padding: 15px;
        }

        .stats-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }

        .stat-item {
            padding: 10px;
            background-color: white;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .stat-label {
            font-weight: 600;
            margin-right: 8px;
        }

        .extensions-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .extension-item {
            display: flex;
            align-items: center;
            padding: 6px 10px;
            background-color: white;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .extension-item input[type="checkbox"] {
            margin-right: 5px;
        }

        .extension-count {
            margin-left: 5px;
            color: #666;
            font-size: 0.9em;
        }

        .tree-view-container {
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 15px;
        }

        .tree-view {
            max-height: 500px;
            overflow-y: auto;
        }

        .tree-item {
            padding: 5px 0;
        }

        .tree-children {
            margin-left: 20px;
        }

        .tree-row {
            display: flex;
            align-items: center;
            padding: 5px;
            border-radius: 4px;
        }

        .tree-row:hover {
            background-color: var(--hover-color);
        }

        .tree-row.selected {
            background-color: var(--selected-color);
        }

        .tree-toggle {
            width: 20px;
            text-align: center;
            cursor: pointer;
        }

        .tree-checkbox {
            margin: 0 5px;
        }

        .tree-item-name {
            margin-left: 5px;
        }

        .tree-directory {
            font-weight: 600;
        }

        .tree-file {
            font-weight: normal;
        }

        .actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .action-summary {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .file-count-info {
            color: var(--secondary-color);
            font-weight: 600;
        }

        .status {
            padding: 10px;
            border-radius: 4px;
        }

        .status.success {
            background-color: #e6f7e6;
            color: #2e7d32;
        }

        .status.error {
            background-color: #fdecea;
            color: #c62828;
        }

        @media (max-width: 768px) {
            .input-group {
                flex-direction: column;
                align-items: stretch;
            }
            
            #selected-dir-path {
                margin-top: 10px;
            }
            
            .stats-container {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Extraktor projektov√Ωch s√∫borov pre AI</h1>
            <p>N√°stroj na vytvorenie textov√©ho s√∫boru zo zdrojov√Ωch k√≥dov projektu pre pou≈æitie ako kontext pre AI.</p>
        </header>
        
        <section class="file-selector">
            <div class="input-group">
                <button id="choose-dir-btn">Vybra≈• adres√°r projektu</button>
                <button id="refresh-btn" disabled title="Obnovi≈• strom adres√°ra">üîÑ Obnovi≈•</button>
                <span id="selected-dir-path">≈Ωiadny adres√°r nebol vybran√Ω</span>
            </div>
            <div id="last-load-time" style="margin-top: 10px; color: #666; font-size: 0.9em;"></div>
        </section>
        
        <section class="stats-panel" id="stats-panel">
            <h2>≈†tatistiky projektu</h2>
            <div class="stats-container">
                <div class="stat-item">
                    <span class="stat-label">Poƒçet adres√°rov:</span>
                    <span class="stat-value" id="dir-count">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Poƒçet s√∫borov:</span>
                    <span class="stat-value" id="file-count">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Vybran√Ωch s√∫borov:</span>
                    <span class="stat-value" id="selected-file-count">0</span>
                </div>
            </div>
        </section>
        
        <section class="extensions-panel" id="extensions-panel">
            <h2>Koncovky s√∫borov</h2>
            <div class="extensions-container" id="extensions-container">
                <!-- Tu bud√∫ dynamicky pridan√© checkboxy pre koncovky -->
            </div>
        </section>
        
        <section class="tree-view-container">
            <h2>Stromov√° ≈°trukt√∫ra projektu</h2>
            <div class="tree-view" id="tree-view">
                <!-- Tu bude dynamicky vytvoren√° stromov√° ≈°trukt√∫ra -->
            </div>
        </section>
        
        <section class="actions">
            <div class="action-summary">
                <button id="generate-btn" disabled>Vygenerova≈• textov√Ω s√∫bor</button>
                <span class="file-count-info" id="action-file-count">0 s√∫borov vybran√Ωch</span>
            </div>
            <div class="split-options" style="margin-top: 10px; display: flex; align-items: center; gap: 10px;">
                <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                    <input type="checkbox" id="split-files-checkbox">
                    <span>Rozdeli≈• do s√∫borov</span>
                </label>
                <label style="display: flex; align-items: center; gap: 5px;">
                    <span>Max:</span>
                    <input type="number" id="max-file-size-kb" value="1000" min="10" max="100000" style="width: 80px; padding: 4px 8px; border: 1px solid var(--border-color); border-radius: 4px;">
                    <span>kB</span>
                </label>
            </div>
            <div class="status" id="status"></div>
        </section>
    </div>
</body>

<script>
//<![CDATA[
// Konfigur√°cia aplik√°cie
const config = {
    // Predvolen√© koncovky s√∫borov, ktor√© bud√∫ automaticky vybran√©
    defaultExtensions: [
        // Programovacie jazyky
        '.js', '.ts', '.jsx', '.tsx', '.html', '.css', '.scss', '.sass', '.less',
        '.java', '.py', '.rb', '.php', '.c', '.cpp', '.h', '.hpp', '.cs', '.go', 
        '.rs', '.swift', '.kt', '.scala', '.dart', '.lua', '.pl', '.sh', '.ps1',
        '.bat', '.cmd', '.vb', '.fs', '.hs', '.clj', '.ex', '.exs', '.erl', '.hrl',
        // Konfiguraƒçn√© s√∫bory
        '.json', '.xml', '.yaml', '.yml', '.toml', '.ini', '.conf', '.config',
        '.properties', '.env', '.editorconfig', '.gitignore', '.gitattributes',
        // Dokument√°cia a markdown
        '.md', '.markdown', '.txt', '.rst', '.asciidoc', '.adoc',
        // D√°tov√© s√∫bory
        '.csv', '.tsv', '.sql'
    ],
    
    // Maxim√°lna veƒækos≈• s√∫boru na naƒç√≠tanie (v bytoch)
    maxFileSize: 10 * 1024 * 1024, // 10 MB
    
    // Identifik√°tor pre localStorage
    storageKey: 'file-extractor-settings',
    
    // Identifik√°tor pre zapam√§tanie adres√°ra
    storageKeyDirHandle: 'file-extractor-dir-handle',
    
    // Form√°t oddeƒæovaƒça pre v√Ωstupn√Ω s√∫bor
    outputSeparator: '\n\n// ===== FILE: {{filePath}} =====\n\n'
};

// Glob√°lne premenn√© pre aplik√°ciu
let rootDirectory = null;
let directoryStructure = null;
let fileExtensions = new Map(); // Mapa na uchovanie inform√°ci√≠ o koncovk√°ch s√∫borov
let selectedExtensions = new Set(config.defaultExtensions);
let expandedNodes = new Set(); // Sledovanie rozbalen√Ωch adres√°rov
let savedDirectoryHandle = null; // Ulo≈æen√Ω handle adres√°ra

// DOM elementy
const chooseDirBtn = document.getElementById('choose-dir-btn');
const refreshBtn = document.getElementById('refresh-btn');
const selectedDirPath = document.getElementById('selected-dir-path');
const lastLoadTime = document.getElementById('last-load-time');
const dirCount = document.getElementById('dir-count');
const fileCount = document.getElementById('file-count');
const selectedFileCount = document.getElementById('selected-file-count');
const actionFileCount = document.getElementById('action-file-count');
const extensionsContainer = document.getElementById('extensions-container');
const treeView = document.getElementById('tree-view');
const generateBtn = document.getElementById('generate-btn');
const statusEl = document.getElementById('status');

// Inicializ√°cia aplik√°cie
document.addEventListener('DOMContentLoaded', init);

// Inicializaƒçn√° funkcia
async function init() {
    // Naƒç√≠tanie ulo≈æen√Ωch nastaven√≠
    loadSettings();
    
    // Naƒç√≠tanie ulo≈æen√©ho adres√°ra
    try {
        await loadSavedDirectory();
    } catch (error) {
        console.error('Chyba pri naƒç√≠tan√≠ adres√°ra:', error);
    }
    
    // Pridanie event listenerov
    chooseDirBtn.addEventListener('click', handleDirectorySelection);
    refreshBtn.addEventListener('click', handleRefresh);
    generateBtn.addEventListener('click', generateOutputFile);

    // Kontrola podpory File API
    if (!window.showDirectoryPicker) {
        showError('V√°≈° prehliadaƒç nepodporuje Directory API. Pou≈æite pros√≠m Chrome alebo Firefox.');
        chooseDirBtn.disabled = true;
    }
}

// Funkcia na naƒç√≠tanie ulo≈æen√Ωch nastaven√≠
function loadSettings() {
    try {
        const savedSettings = localStorage.getItem(config.storageKey);
        if (savedSettings) {
            const settings = JSON.parse(savedSettings);
            if (settings.selectedExtensions) {
                selectedExtensions = new Set(settings.selectedExtensions);
            }
        }
    } catch (error) {
        console.error('Chyba pri naƒç√≠tan√≠ nastaven√≠:', error);
    }
}

// Funkcia na ulo≈æenie nastaven√≠
function saveSettings() {
    try {
        const settings = {
            selectedExtensions: Array.from(selectedExtensions)
        };
        localStorage.setItem(config.storageKey, JSON.stringify(settings));
    } catch (error) {
        console.error('Chyba pri ukladan√≠ nastaven√≠:', error);
    }
}

// Funkcia na naƒç√≠tanie ulo≈æen√©ho adres√°ra
async function loadSavedDirectory() {
    try {
        // Sk√∫sime najprv naƒç√≠ta≈• z IndexedDB (ak je podporovan√°)
        if (window.indexedDB) {
            try {
                const db = await openDatabase();
                const handle = await getDirHandleFromDB(db);
                
                if (handle) {
                    savedDirectoryHandle = handle;
                    
                    // Skontrolujeme, ƒçi m√°me e≈°te povolenie pristupova≈• k adres√°ru
                    if (handle.requestPermission) {
                        const permission = await handle.requestPermission({ mode: 'read' });
                        if (permission === 'granted') {
                            // Nastav√≠me ulo≈æen√Ω adres√°r ako akt√≠vny
                            rootDirectory = handle;
                            
                            // Aktualizujeme UI
                            selectedDirPath.textContent = handle.name;
                            showStatus(`Adres√°r "${handle.name}" je pripraven√Ω na pou≈æitie.`, 'success');
                            
                            // Spracujeme adres√°rov√∫ ≈°trukt√∫ru
                            await processSelectedDirectory();
                            return;
                        }
                    }
                }
            } catch (error) {
                console.warn('Nepodarilo sa obnovi≈• ulo≈æen√Ω adres√°r:', error);
            }
        }
        
        // Fallback - sk√∫sime naƒç√≠ta≈• aspo≈à n√°zov adres√°ra z localStorage
        const lastDirInfo = localStorage.getItem(config.storageKeyDirHandle);
        if (lastDirInfo) {
            try {
                const dirInfo = JSON.parse(lastDirInfo);
                selectedDirPath.textContent = `Naposledy pou≈æit√Ω: ${dirInfo.name}`;
                showStatus('Kliknite na "Vybra≈• adres√°r projektu" pre op√§tovn√© naƒç√≠tanie naposledy pou≈æit√©ho adres√°ra.', 'success');
            } catch (error) {
                console.warn('Nepodarilo sa naƒç√≠ta≈• inform√°cie o adres√°ri:', error);
            }
        }
    } catch (error) {
        console.error('Chyba pri naƒç√≠tan√≠ adres√°ra:', error);
    }
}

// Funkcia na otvorenie IndexedDB datab√°zy
function openDatabase() {
    return new Promise((resolve, reject) => {
        if (!window.indexedDB) {
            reject(new Error('Prehliadaƒç nepodporuje IndexedDB'));
            return;
        }
        
        const request = indexedDB.open('FileExtractorDB', 1);
        
        request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains('directoryHandles')) {
                db.createObjectStore('directoryHandles');
            }
        };
        
        request.onsuccess = (event) => {
            resolve(event.target.result);
        };
        
        request.onerror = (event) => {
            console.error('Chyba pri otv√°ran√≠ datab√°zy:', event.target.error);
            reject(event.target.error);
        };
    });
}

// Funkcia na z√≠skanie handle adres√°ra z datab√°zy
function getDirHandleFromDB(db) {
    return new Promise((resolve, reject) => {
        try {
            const transaction = db.transaction(['directoryHandles'], 'readonly');
            const store = transaction.objectStore('directoryHandles');
            const request = store.get('lastUsed');
            
            request.onsuccess = (event) => {
                resolve(event.target.result);
            };
            
            request.onerror = (event) => {
                console.error('Chyba pri z√≠skavan√≠ adres√°ra z datab√°zy:', event.target.error);
                reject(event.target.error);
            };
        } catch (error) {
            reject(error);
        }
    });
}

// Funkcia na ulo≈æenie handle adres√°ra do datab√°zy
async function saveDirHandleToDB(handle) {
    try {
        if (!window.indexedDB) {
            throw new Error('Prehliadaƒç nepodporuje IndexedDB');
        }
        
        // Po≈æiadame o povolenie persistentn√©ho √∫lo≈æiska
        if (navigator.storage && navigator.storage.persist) {
            const isPersisted = await navigator.storage.persist();
            console.log(`Persistentn√© √∫lo≈æisko ${isPersisted ? 'povolen√©' : 'zamietnut√©'}`);
        }
        
        // Ulo≈æ√≠me handle do IndexedDB
        const db = await openDatabase();
        const transaction = db.transaction(['directoryHandles'], 'readwrite');
        const store = transaction.objectStore('directoryHandles');
        await store.put(handle, 'lastUsed');
        
        // Ulo≈æ√≠me inform√°cie o adres√°ri aj do localStorage ako fallback
        localStorage.setItem(config.storageKeyDirHandle, JSON.stringify({
            name: handle.name,
            kind: handle.kind,
            timestamp: Date.now()
        }));
        
        return true;
    } catch (error) {
        console.error('Chyba pri ukladan√≠ adres√°ra:', error);
        
        // Fallback - ulo≈æ√≠me aspo≈à z√°kladn√© inform√°cie do localStorage
        if (handle && handle.name) {
            localStorage.setItem(config.storageKeyDirHandle, JSON.stringify({
                name: handle.name,
                kind: handle.kind,
                timestamp: Date.now()
            }));
        }
        
        return false;
    }
}

// Funkcia na aktualiz√°ciu ƒçasu posledn√©ho naƒç√≠tania
function updateLastLoadTime() {
    const now = new Date();
    const dateStr = now.toLocaleDateString('sk-SK', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric'
    });
    const timeStr = now.toLocaleTimeString('sk-SK', {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
    });
    lastLoadTime.textContent = `Posledn√© naƒç√≠tanie: ${dateStr} ${timeStr}`;
}

// Funkcia na z√≠skanie v≈°etk√Ωch vybran√Ωch ciest s√∫borov
function getSelectedFilePaths() {
    const selectedPaths = new Set();

    function collectSelected(node) {
        if (node.type === 'file' && node.selected === true) {
            selectedPaths.add(node.path);
        } else if (node.type === 'directory' && node.children) {
            for (const child of node.children) {
                collectSelected(child);
            }
        }
    }

    if (directoryStructure) {
        collectSelected(directoryStructure);
    }

    return selectedPaths;
}

// Funkcia na obnovenie v√Ωberu s√∫borov podƒæa ulo≈æen√Ωch ciest
function restoreSelectedFilePaths(selectedPaths) {
    if (!selectedPaths || selectedPaths.size === 0) return;

    function restoreSelection(node) {
        if (node.type === 'file') {
            // Obnov√≠me v√Ωber len ak bol s√∫bor predt√Ωm vybran√Ω
            // Inak explicitne nastav√≠me selected na false
            if (selectedPaths.has(node.path)) {
                node.selected = true;
            } else {
                node.selected = false;
            }
        } else if (node.type === 'directory' && node.children) {
            // Rekurz√≠vne spracujeme deti
            for (const child of node.children) {
                restoreSelection(child);
            }
            // Aktualizujeme stav adres√°ra na z√°klade det√≠
            updateDirectorySelectionState(node);
        }
    }

    if (directoryStructure) {
        restoreSelection(directoryStructure);
    }
}

// Handler pre obnovenie stromu adres√°ra
async function handleRefresh() {
    if (!rootDirectory) {
        showError('Nie je vybran√Ω ≈æiadny adres√°r.');
        return;
    }

    try {
        // Deaktiv√°cia tlaƒçidiel poƒças naƒç√≠tavania
        refreshBtn.disabled = true;
        generateBtn.disabled = true;

        showStatus('Obnovujem strom adres√°ra...');

        // Ulo≈æ√≠me si aktu√°lny v√Ωber s√∫borov pred obnoven√≠m
        const previouslySelectedPaths = getSelectedFilePaths();

        // Znovu spracujeme adres√°r
        await processSelectedDirectory();

        // Obnov√≠me v√Ωber s√∫borov podƒæa ulo≈æen√Ωch ciest
        restoreSelectedFilePaths(previouslySelectedPaths);

        // Aktualizujeme stav koncoviek na z√°klade obnoven√©ho v√Ωberu
        synchronizeExtensionsWithFiles();

        // Prekresl√≠me strom so spr√°vnym stavom v√Ωberu
        renderTreeView();

        // Aktualizujeme UI
        updateExtensionsUI();
        updateTotalSelectedFilesCount();

        showStatus('Strom adres√°ra bol √∫spe≈°ne obnoven√Ω.', 'success');

    } catch (error) {
        console.error('Chyba pri obnoven√≠ adres√°ra:', error);
        showError(`Chyba pri obnoven√≠ adres√°ra: ${error.message}`);
    } finally {
        // Op√§tovn√© povolenie tlaƒçidla
        refreshBtn.disabled = false;
    }
}

// Handler pre v√Ωber adres√°ra
async function handleDirectorySelection() {
    try {
        // Otvorenie dial√≥gu pre v√Ωber adres√°ra
        // Sk√∫sime vyu≈æi≈• ulo≈æen√Ω adres√°r ako poƒçiatoƒçn√Ω bod, ak je k dispoz√≠cii
        let options = {};
        
        if (savedDirectoryHandle) {
            // Niektor√© prehliadaƒçe podporuj√∫ id a startIn mo≈ænosti
            options = {
                id: savedDirectoryHandle.name,
                startIn: savedDirectoryHandle
            };
        }
        
        try {
            rootDirectory = await window.showDirectoryPicker(options);
        } catch (error) {
            // Ak sa nepodar√≠ pou≈æi≈• options, sk√∫sime bez nich
            if (error.name !== 'AbortError') {
                console.warn('Nepodarilo sa pou≈æi≈• ulo≈æen√Ω adres√°r, sk√∫≈°am bez mo≈ænost√≠:', error);
                rootDirectory = await window.showDirectoryPicker();
            } else {
                // Pou≈æ√≠vateƒæ zru≈°il v√Ωber adres√°ra
                throw error;
            }
        }
        
        // Ulo≈æ√≠me nov√Ω adres√°r pre bud√∫ce pou≈æitie
        savedDirectoryHandle = rootDirectory;
        await saveDirHandleToDB(rootDirectory);
        
        // Spracujeme vybran√Ω adres√°r
        await processSelectedDirectory();
        
    } catch (error) {
        if (error.name !== 'AbortError') { // Ignorovanie "cancel" akcie od pou≈æ√≠vateƒæa
            console.error('Chyba pri v√Ωbere adres√°ra:', error);
            showError(`Chyba pri v√Ωbere adres√°ra: ${error.message}`);
        }
    }
}

// Funkcia na spracovanie vybran√©ho adres√°ra
async function processSelectedDirectory() {
    if (!rootDirectory) return;
    
    // Aktualiz√°cia UI
    selectedDirPath.textContent = rootDirectory.name;
    generateBtn.disabled = true;
    showStatus('Naƒç√≠tavam adres√°rov√∫ ≈°trukt√∫ru...');
    
    // Resetovanie premenn√Ωch
    directoryStructure = null;
    fileExtensions.clear();
    
    // Spracovanie adres√°rovej ≈°trukt√∫ry (asynchr√≥nne)
    directoryStructure = await processDirectory(rootDirectory);
    
    // Aktualiz√°cia UI
    updateStatistics();
    updateExtensionsUI();
    renderTreeView();
    updateTotalSelectedFilesCount();

    generateBtn.disabled = false;
    refreshBtn.disabled = false; // Povolenie refresh tlaƒçidla
    updateLastLoadTime(); // Aktualiz√°cia ƒçasu naƒç√≠tania
    showStatus('Adres√°rov√° ≈°trukt√∫ra bola √∫spe≈°ne naƒç√≠tan√°.', 'success');

    // Ulo≈æenie nastaven√≠
    saveSettings();
}

// Funkcia na spracovanie adres√°ra a vytvorenie stromovej ≈°trukt√∫ry
async function processDirectory(directoryHandle, parentPath = null) {
    const isRoot = parentPath === null;
    const currentPath = isRoot ? directoryHandle.name : `${parentPath}/${directoryHandle.name}`;

    const result = {
        type: 'directory',
        name: directoryHandle.name,
        path: currentPath,
        handle: directoryHandle,
        children: [],
        selected: false
    };

    // Iter√°cia cez v≈°etky polo≈æky v adres√°ri
    for await (const entry of directoryHandle.values()) {
        if (entry.kind === 'directory') {
            // Rekurz√≠vne spracovanie podadres√°ra
            const subDir = await processDirectory(entry, currentPath);
            result.children.push(subDir);
        } else {
            // Spracovanie s√∫boru
            const file = {
                type: 'file',
                name: entry.name,
                path: `${currentPath}/${entry.name}`,
                handle: entry,
                selected: false,
                extension: getFileExtension(entry.name)
            };
            
            // Z√≠skanie a spracovanie koncovky s√∫boru
            if (file.extension) {
                // Aktualiz√°cia poƒçtu s√∫borov pre dan√∫ koncovku
                if (!fileExtensions.has(file.extension)) {
                    fileExtensions.set(file.extension, {
                        count: 1,
                        selected: selectedExtensions.has(file.extension)
                    });
                } else {
                    const extInfo = fileExtensions.get(file.extension);
                    extInfo.count++;
                    fileExtensions.set(file.extension, extInfo);
                }
                
                // Nastavenie, ƒçi je s√∫bor vybran√Ω, na z√°klade jeho koncovky
                file.selected = fileExtensions.get(file.extension).selected;
            }
            
            result.children.push(file);
        }
    }
    
    // Odvodzujeme stav v√Ωberu adres√°ra na z√°klade stavu jeho det√≠
    updateDirectorySelectionState(result);
    
    return result;
}

// Funkcia na z√≠skanie koncovky s√∫boru
function getFileExtension(filename) {
    const parts = filename.split('.');
    if (parts.length === 1 || (parts[0] === '' && parts.length === 2)) {
        return ''; // S√∫bor bez koncovky alebo skryt√Ω s√∫bor (napr. .gitignore)
    }
    return '.' + parts.pop().toLowerCase();
}

// Funkcia na aktualiz√°ciu ≈°tatist√≠k
function updateStatistics() {
    if (!directoryStructure) return;
    
    let dirs = 0;
    let files = 0;
    
    function countItems(node) {
        if (node.type === 'directory') {
            dirs++;
            for (const child of node.children) {
                countItems(child);
            }
        } else {
            files++;
        }
    }
    
    countItems(directoryStructure);
    
    // Odpoƒç√≠tame kore≈àov√Ω adres√°r
    dirs--;
    
    // Aktualiz√°cia UI
    dirCount.textContent = dirs;
    fileCount.textContent = files;
}

// Funkcia na poƒç√≠tanie vybran√Ωch s√∫borov
function updateTotalSelectedFilesCount() {
    if (!directoryStructure) {
        selectedFileCount.textContent = "0";
        actionFileCount.textContent = "0 s√∫borov vybran√Ωch";
        return;
    }
    
    let count = 0;
    
    function countSelectedFiles(node) {
        if (node.type === 'file' && node.selected) {
            count++;
        } else if (node.type === 'directory') {
            for (const child of node.children) {
                countSelectedFiles(child);
            }
        }
    }
    
    countSelectedFiles(directoryStructure);
    
    // Aktualiz√°cia poƒç√≠tadiel
    selectedFileCount.textContent = count;
    
    // Generovanie textu so spr√°vnym sklo≈àovan√≠m
    let fileText = "s√∫borov";
    if (count === 1) {
        fileText = "s√∫bor";
    } else if (count >= 2 && count <= 4) {
        fileText = "s√∫bory";
    }
    
    actionFileCount.textContent = `${count} ${fileText} vybran√Ωch`;
    
    // Zablokujeme tlaƒçidlo na generovanie, ak nie s√∫ vybran√© ≈æiadne s√∫bory
    generateBtn.disabled = count === 0;
}

// Funkcia na synchroniz√°ciu stavu koncoviek so stavom s√∫borov
function synchronizeExtensionsWithFiles() {
    if (!directoryStructure) return;
    
    // Najprv resetujeme v≈°etky koncovky
    const extensionsStatus = new Map();
    
    // Prejdeme cel√Ω strom a zaznamen√°me stav koncoviek
    function trackExtensions(node) {
        if (node.type === 'file' && node.extension) {
            const ext = node.extension;
            if (!extensionsStatus.has(ext)) {
                extensionsStatus.set(ext, {
                    count: 1,
                    selectedCount: node.selected ? 1 : 0
                });
            } else {
                const status = extensionsStatus.get(ext);
                status.count++;
                if (node.selected) status.selectedCount++;
                extensionsStatus.set(ext, status);
            }
        } else if (node.type === 'directory') {
            for (const child of node.children) {
                trackExtensions(child);
            }
        }
    }
    
    // Zaƒç√≠name od kore≈àov√©ho adres√°ra
    trackExtensions(directoryStructure);
    
    // Aktualizujeme inform√°cie o koncovk√°ch
    for (const [ext, info] of fileExtensions.entries()) {
        const status = extensionsStatus.get(ext);
        if (status) {
            const isSelected = status.selectedCount > 0;
            info.selected = isSelected;
            info.selectedCount = status.selectedCount;
            
            // Aktualizujeme aj mno≈æinu vybran√Ωch koncoviek
            if (isSelected) {
                selectedExtensions.add(ext);
            } else {
                selectedExtensions.delete(ext);
            }
        }
    }
    
    // Ulo≈æ√≠me nastavenia
    saveSettings();
    
    // Aktualiz√°cia poƒçtu celkovo vybran√Ωch s√∫borov
    updateTotalSelectedFilesCount();
}

// Funkcia na aktualiz√°ciu UI koncoviek s√∫borov
function updateExtensionsUI() {
    extensionsContainer.innerHTML = '';
    
    // Zoradenie koncoviek podƒæa poƒçtu s√∫borov
    const sortedExtensions = Array.from(fileExtensions.entries()).sort((a, b) => {
        // Najprv zorad√≠me podƒæa vybran√©ho stavu (vybran√© koncovky na zaƒçiatku)
        if (a[1].selected !== b[1].selected) {
            return b[1].selected - a[1].selected;
        }
        // Potom podƒæa poƒçtu s√∫borov (zostupne)
        return b[1].count - a[1].count;
    });
    
    for (const [ext, info] of sortedExtensions) {
        const extItem = document.createElement('div');
        extItem.className = 'extension-item';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = info.selected;
        checkbox.dataset.extension = ext;
        
        checkbox.addEventListener('change', (e) => {
            const extension = e.target.dataset.extension;
            const selected = e.target.checked;
            
            // Aktualiz√°cia stavu koncovky
            const extInfo = fileExtensions.get(extension);
            extInfo.selected = selected;
            fileExtensions.set(extension, extInfo);
            
            if (selected) {
                selectedExtensions.add(extension);
            } else {
                selectedExtensions.delete(extension);
            }
            
            // Nastavenie v≈°etk√Ωch s√∫borov s danou koncovkou 
            updateAllFilesByExtension(directoryStructure, extension, selected);
            
            // Aktualiz√°cia stavu koncoviek - prepoƒç√≠tame poƒçet vybran√Ωch s√∫borov
            synchronizeExtensionsWithFiles();
            
            // Prekreslenie UI koncoviek, aby sa aktualizovali poƒçty
            updateExtensionsUI();
            
            // Aktualiz√°cia poƒçtu celkovo vybran√Ωch s√∫borov
            updateTotalSelectedFilesCount();
            
            // Ulo≈æenie nastaven√≠
            saveSettings();
        });
        
        const label = document.createElement('label');
        label.textContent = ext || '(bez koncovky)';
        
        const count = document.createElement('span');
        count.className = 'extension-count';
        
        // Zobraz√≠me poƒçet vybran√Ωch s√∫borov a celkov√Ω poƒçet s√∫borov
        const selectedCount = info.selectedCount || 0;
        count.textContent = `(${selectedCount}/${info.count})`;
        
        extItem.appendChild(checkbox);
        extItem.appendChild(label);
        extItem.appendChild(count);
        
        extensionsContainer.appendChild(extItem);
    }
}

// Aktualiz√°cia v≈°etk√Ωch s√∫borov s danou koncovkou
function updateAllFilesByExtension(node, extension, selected) {
    let changed = false;
    
    if (node.type === 'file' && node.extension === extension) {
        // Zmena stavu len ak je in√Ω ako aktu√°lny
        if (node.selected !== selected) {
            node.selected = selected;
            changed = true;
        }
    } else if (node.type === 'directory') {
        // Rekurz√≠vne prech√°dzame v≈°etky deti
        for (const child of node.children) {
            if (updateAllFilesByExtension(child, extension, selected)) {
                changed = true;
            }
        }
        
        // Ak do≈°lo k zmene, aktualizujeme stav adres√°ra
        if (changed) {
            // Prepoƒç√≠tame stav adres√°ra na z√°klade jeho det√≠
            updateDirectorySelectionState(node);
        }
    }
    
    // Ak sa jedn√° o kore≈àov√Ω adres√°r a do≈°lo k zmene, aktualizujeme checkboxy
    if (node === directoryStructure && changed) {
        updateCheckboxStatesInDOM();
    }
    
    return changed;
}

// Funkcia na aktualiz√°ciu stavu v√Ωberu adres√°ra na z√°klade jeho det√≠
function updateDirectorySelectionState(directory) {
    if (!directory || !directory.children || directory.children.length === 0) {
        directory.selected = false;
        return;
    }
    
    const allSelected = directory.children.every(child => child.selected === true);
    const noneSelected = directory.children.every(child => child.selected === false);
    
    if (allSelected) {
        directory.selected = true;
    } else if (noneSelected) {
        directory.selected = false;
    } else {
        directory.selected = null; // Neurƒçit√Ω stav
    }
}

// Funkcia na efekt√≠vnu aktualiz√°ciu checkbox stavov bez prekreslenia cel√©ho stromu
function updateCheckboxStatesInDOM() {
    if (!directoryStructure) return;

    // Prejdeme v≈°etky checkboxy v stromovej ≈°trukt√∫re
    const checkboxes = treeView.querySelectorAll('.tree-checkbox[data-path]');

    checkboxes.forEach(checkbox => {
        const path = checkbox.dataset.path;
        const node = findNodeByPath(directoryStructure, path);

        if (node) {
            checkbox.checked = node.selected === true;
            checkbox.indeterminate = node.selected === null;
        }
    });
}

// Funkcia na vykreslenie stromovej ≈°trukt√∫ry
function renderTreeView() {
    // Zapam√§t√°me si rozbalen√© uzly pred prekreslen√≠m
    const expandedElements = document.querySelectorAll('.tree-children[style="display: block;"]');
    expandedElements.forEach(el => {
        const parentItem = el.closest('.tree-item');
        if (parentItem && parentItem.dataset.path) {
            expandedNodes.add(parentItem.dataset.path);
        }
    });
    
    treeView.innerHTML = '';
    
    if (!directoryStructure) return;
    
    // Pre kore≈àov√Ω adres√°r v≈ædy nastav√≠me rozbalenie
    expandedNodes.add(directoryStructure.path);
    
    treeView.appendChild(createTreeItem(directoryStructure));
}

// Funkcia na vytvorenie polo≈æky stromovej ≈°trukt√∫ry
function createTreeItem(node) {
    const item = document.createElement('div');
    item.className = 'tree-item';
    item.dataset.path = node.path;
    
    const row = document.createElement('div');
    row.className = 'tree-row';
    
    // Tlaƒçidlo na rozbalenie/zbalenie (len pre adres√°re)
    const toggle = document.createElement('span');
    toggle.className = 'tree-toggle';
    
    if (node.type === 'directory' && node.children.length > 0) {
        toggle.textContent = '‚ñ∂';
        toggle.style.cursor = 'pointer';
        
        // Event listener pre rozbalenie/zbalenie
        toggle.addEventListener('click', (e) => {
            e.stopPropagation(); // Zabr√°ni≈• ≈°√≠reniu udalosti
            const children = item.querySelector('.tree-children');
            if (children.style.display === 'none') {
                children.style.display = 'block';
                toggle.textContent = '‚ñº';
                expandedNodes.add(node.path);
            } else {
                children.style.display = 'none';
                toggle.textContent = '‚ñ∂';
                expandedNodes.delete(node.path);
            }
        });
    } else {
        toggle.textContent = ' ';
    }
    
    // Checkbox pre v√Ωber
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.className = 'tree-checkbox';
    checkbox.dataset.path = node.path; // Prid√°me cestu pre efekt√≠vnu aktualiz√°ciu
    checkbox.checked = node.selected === true;
    checkbox.indeterminate = node.selected === null;
    
    // Event listener pre zmenu v√Ωberu
    checkbox.addEventListener('change', (e) => {
        e.stopPropagation(); // Zabr√°ni≈• ≈°√≠reniu udalosti
        
        // Z√≠skanie aktu√°lneho stavu
        let selected = checkbox.checked;
        
        // ≈†peci√°lne spracovanie pre neurƒçit√Ω stav - jednoduch√Ω cyklus:
        // neurƒçit√Ω -> vybran√Ω -> nevybran√Ω
        if (node.selected === null && !selected) {
            selected = true;
            checkbox.checked = true;
        }
        
        // Nastavenie stavu aktu√°lneho uzla
        node.selected = selected;
        
        // Ak je to adres√°r, rekurz√≠vne nastav√≠me rovnak√Ω stav pre v≈°etky jeho deti
        if (node.type === 'directory') {
            setAllChildrenSelection(node, selected);
        }
        
        // Aktualiz√°cia stavu rodiƒçovsk√Ωch adres√°rov smerom nahor
        if (node !== directoryStructure) {
            updateParentSelectionStates(directoryStructure, node.path);
        }
        
        // Aktualiz√°cia stavu koncoviek
        synchronizeExtensionsWithFiles();

        // Aktualiz√°cia UI - len checkboxy, nie cel√Ω strom
        updateCheckboxStatesInDOM();
        updateExtensionsUI();
        updateTotalSelectedFilesCount();
    });
    
    // N√°zov polo≈æky
    const name = document.createElement('span');
    name.className = `tree-item-name ${node.type === 'directory' ? 'tree-directory' : 'tree-file'}`;
    name.textContent = node.name;
    
    row.appendChild(toggle);
    row.appendChild(checkbox);
    row.appendChild(name);
    
    item.appendChild(row);
    
    // Vytvorenie podpolo≈æiek pre adres√°re
    if (node.type === 'directory' && node.children.length > 0) {
        const children = document.createElement('div');
        children.className = 'tree-children';
        
        // Pre kore≈àov√Ω adres√°r v≈ædy zobraz√≠me deti
        if (node === directoryStructure || expandedNodes.has(node.path)) {
            toggle.textContent = '‚ñº';
            children.style.display = 'block';
        } else {
            children.style.display = 'none';
        }
        
        // Zoradenie det√≠: najprv adres√°re, potom s√∫bory, v≈°etko abecedne
        const sortedChildren = [...node.children].sort((a, b) => {
            if (a.type !== b.type) {
                return a.type === 'directory' ? -1 : 1;
            }
            return a.name.localeCompare(b.name);
        });
        
        for (const child of sortedChildren) {
            children.appendChild(createTreeItem(child));
        }
        
        item.appendChild(children);
    }
    
    return item;
}

// Lep≈°ia funkcia pre rekurz√≠vne nastavenie v≈°etk√Ωch det√≠ adres√°ra
function setAllChildrenSelection(directory, selected) {
    if (!directory || directory.type !== 'directory') return;
    
    // Pre v≈°etky deti nastav√≠me vybran√Ω stav
    for (let i = 0; i < directory.children.length; i++) {
        const child = directory.children[i];
        child.selected = selected;
        
        // Ak je die≈•a adres√°r, rekurz√≠vne nastav√≠me aj jeho deti
        if (child.type === 'directory') {
            setAllChildrenSelection(child, selected);
        }
    }
}

// Funkcia pre aktualiz√°ciu stavu rodiƒçov
function updateParentSelectionStates(root, childPath) {
    if (root.type !== 'directory') return false;
    
    let changed = false;
    
    // Skontrolujeme, ƒçi je tento uzol alebo niektor√Ω z jeho det√≠ hƒæadan√Ωm potomkom
    let isParentOfChangedNode = false;
    for (const child of root.children) {
        // Priamy potomok alebo je v podstrome
        if (child.path === childPath || 
            (child.type === 'directory' && childPath.startsWith(child.path + '/'))) {
            isParentOfChangedNode = true;
            if (child.type === 'directory') {
                updateParentSelectionStates(child, childPath);
            }
            break;
        }
    }
    
    // Ak je rodiƒçom zmenen√©ho uzla, prepoƒç√≠tame jeho stav
    if (isParentOfChangedNode) {
        const oldSelection = root.selected;
        updateDirectorySelectionState(root);
        return oldSelection !== root.selected;
    }
    
    return false;
}

// Funkcia na n√°jdenie uzla podƒæa cesty
function findNodeByPath(root, path) {
    if (root.path === path) return root;
    
    if (root.type === 'directory') {
        for (const child of root.children) {
            const found = findNodeByPath(child, path);
            if (found) return found;
        }
    }
    
    return null;
}

// Funkcia na generovanie v√Ωstupn√©ho s√∫boru
async function generateOutputFile() {
    if (!directoryStructure) {
        showError('Najprv vyberte adres√°r projektu.');
        return;
    }

    try {
        const splitFilesCheckbox = document.getElementById('split-files-checkbox');
        const maxFileSizeKbInput = document.getElementById('max-file-size-kb');
        const shouldSplit = splitFilesCheckbox.checked;
        const maxFileSizeBytes = parseInt(maxFileSizeKbInput.value, 10) * 1024;

        if (shouldSplit) {
            showStatus('Generujem rozdelen√© textov√© s√∫bory...');
            await generateSplitFiles(directoryStructure, maxFileSizeBytes);
        } else {
            showStatus('Generujem textov√Ω s√∫bor...');

            // Vytvorenie obsahu v√Ωstupn√©ho s√∫boru
            const content = await generateFileContent(directoryStructure);

            // Vytvorenie a stiahnutie s√∫boru
            downloadTextFile(content, `${directoryStructure.name}_context.txt`);

            showStatus('Textov√Ω s√∫bor bol √∫spe≈°ne vygenerovan√Ω.', 'success');
        }
    } catch (error) {
        console.error('Chyba pri generovan√≠ s√∫boru:', error);
        showError(`Chyba pri generovan√≠ s√∫boru: ${error.message}`);
    }
}

// Funkcia na stiahnutie textov√©ho s√∫boru
function downloadTextFile(content, filename) {
    const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();

    // Odstr√°nenie doƒçasn√©ho prvku a uvoƒænenie URL
    setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }, 0);
}

// Funkcia na z√≠skanie zoznamu v≈°etk√Ωch vybran√Ωch s√∫borov s ich obsahom
async function getSelectedFilesWithContent(root) {
    const files = [];

    async function processNode(node) {
        if (node.type === 'file' && node.selected) {
            try {
                const fileHandle = node.handle;
                const file = await fileHandle.getFile();
                let content;
                let isOversized = false;

                if (file.size > config.maxFileSize) {
                    content = `// S√∫bor je pr√≠li≈° veƒæk√Ω (${formatFileSize(file.size)}), prekraƒçuje limit ${formatFileSize(config.maxFileSize)}\n`;
                    isOversized = true;
                } else {
                    content = await readFileAsText(file);
                }

                files.push({
                    path: node.path,
                    content: content,
                    size: new Blob([config.outputSeparator.replace('{{filePath}}', node.path) + content]).size,
                    isOversized: isOversized
                });
            } catch (error) {
                console.error(`Chyba pri ƒç√≠tan√≠ s√∫boru ${node.path}:`, error);
                const errorContent = `// Chyba pri ƒç√≠tan√≠ s√∫boru: ${error.message}\n`;
                files.push({
                    path: node.path,
                    content: errorContent,
                    size: new Blob([config.outputSeparator.replace('{{filePath}}', node.path) + errorContent]).size,
                    isOversized: false
                });
            }
        } else if (node.type === 'directory') {
            for (const child of node.children) {
                if (child.selected === true || child.selected === null) {
                    await processNode(child);
                }
            }
        }
    }

    await processNode(root);
    return files;
}

// Funkcia na generovanie rozdelen√Ωch s√∫borov
async function generateSplitFiles(root, maxSizeBytes) {
    const allFiles = await getSelectedFilesWithContent(root);

    if (allFiles.length === 0) {
        showError('Nie s√∫ vybran√© ≈æiadne s√∫bory.');
        return;
    }

    const outputFiles = [];
    let currentFileContent = '';
    let currentFileSize = 0;
    let currentFileIndex = 1;

    for (const file of allFiles) {
        const separator = config.outputSeparator.replace('{{filePath}}', file.path);
        const fullContent = separator + file.content;
        const fullContentSize = new Blob([fullContent]).size;

        // Ak je s√∫bor v√§ƒç≈°√≠ ako maxim√°lna veƒækos≈•, mus√≠me ho rozdeli≈•
        if (fullContentSize > maxSizeBytes) {
            // Najprv ulo≈æ√≠me aktu√°lny s√∫bor, ak obsahuje nieƒço
            if (currentFileContent.length > 0) {
                outputFiles.push({
                    index: currentFileIndex,
                    content: currentFileContent
                });
                currentFileIndex++;
                currentFileContent = '';
                currentFileSize = 0;
            }

            // Rozdel√≠me veƒæk√Ω s√∫bor na ƒçasti
            const parts = splitLargeFile(file.path, file.content, maxSizeBytes);

            for (let i = 0; i < parts.length; i++) {
                const part = parts[i];
                const partSize = new Blob([part]).size;

                // Ak sa ƒças≈• nezmest√≠ do aktu√°lneho s√∫boru, zaƒçneme nov√Ω
                if (currentFileSize + partSize > maxSizeBytes && currentFileContent.length > 0) {
                    outputFiles.push({
                        index: currentFileIndex,
                        content: currentFileContent
                    });
                    currentFileIndex++;
                    currentFileContent = '';
                    currentFileSize = 0;
                }

                currentFileContent += part;
                currentFileSize += partSize;
            }
        } else {
            // Ak sa s√∫bor nezmest√≠ do aktu√°lneho v√Ωstupn√©ho s√∫boru, zaƒçneme nov√Ω
            if (currentFileSize + fullContentSize > maxSizeBytes && currentFileContent.length > 0) {
                outputFiles.push({
                    index: currentFileIndex,
                    content: currentFileContent
                });
                currentFileIndex++;
                currentFileContent = '';
                currentFileSize = 0;
            }

            currentFileContent += fullContent;
            currentFileSize += fullContentSize;
        }
    }

    // Ulo≈æ√≠me posledn√Ω s√∫bor
    if (currentFileContent.length > 0) {
        outputFiles.push({
            index: currentFileIndex,
            content: currentFileContent
        });
    }

    // Stiahnutie v≈°etk√Ωch s√∫borov
    const baseName = directoryStructure.name;
    const totalFiles = outputFiles.length;

    for (const outputFile of outputFiles) {
        const filename = totalFiles === 1
            ? `${baseName}_context.txt`
            : `${baseName}_context_${String(outputFile.index).padStart(3, '0')}.txt`;

        downloadTextFile(outputFile.content, filename);

        // Mal√° pauza medzi stiahnutiami, aby prehliadaƒç stihol spracova≈•
        await new Promise(resolve => setTimeout(resolve, 100));
    }

    showStatus(`√öspe≈°ne vygenerovan√Ωch ${totalFiles} s√∫bor${totalFiles === 1 ? '' : totalFiles < 5 ? 'y' : 'ov'}.`, 'success');
}

// Funkcia na rozdelenie veƒæk√©ho s√∫boru na ƒçasti
function splitLargeFile(filePath, content, maxSizeBytes) {
    const parts = [];
    const lines = content.split('\n');

    // Odhadneme koƒæko ƒçast√≠ budeme potrebova≈•
    const contentSize = new Blob([content]).size;
    const estimatedParts = Math.ceil(contentSize / maxSizeBytes);

    let currentPart = '';
    let currentPartSize = 0;
    let partIndex = 1;

    // Rezerva pre hlaviƒçky a p√§tiƒçky
    const headerTemplate = `\n// ===== ${filePath} - ƒåAS≈§ ${partIndex}/${estimatedParts} (ZAƒåIATOK) =====\n\n`;
    const footerTemplate = `\n// ===== ${filePath} - ƒåAS≈§ ${partIndex}/${estimatedParts} (KONIEC) =====\n`;
    const headerFooterReserve = new Blob([headerTemplate + footerTemplate]).size + 200; // +200 pre istotu

    const effectiveMaxSize = maxSizeBytes - headerFooterReserve;

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const lineWithNewline = i < lines.length - 1 ? line + '\n' : line;
        const lineSize = new Blob([lineWithNewline]).size;

        // Ak by pridanie riadku prekroƒçilo limit, ukonƒç√≠me aktu√°lnu ƒças≈•
        if (currentPartSize + lineSize > effectiveMaxSize && currentPart.length > 0) {
            // Ukonƒç√≠me aktu√°lnu ƒças≈•
            const totalParts = Math.ceil((contentSize - new Blob([currentPart]).size) / effectiveMaxSize) + partIndex;
            const header = `\n// ===== ${filePath} - ƒåAS≈§ ${partIndex}/${totalParts} (ZAƒåIATOK) =====\n\n`;
            const footer = `\n// ===== ${filePath} - ƒåAS≈§ ${partIndex}/${totalParts} (KONIEC) =====\n`;

            parts.push(header + currentPart + footer);
            partIndex++;
            currentPart = '';
            currentPartSize = 0;
        }

        currentPart += lineWithNewline;
        currentPartSize += lineSize;
    }

    // Prid√°me posledn√∫ ƒças≈•
    if (currentPart.length > 0) {
        const totalParts = partIndex;
        const isLastPart = partIndex === totalParts;
        const header = `\n// ===== ${filePath} - ƒåAS≈§ ${partIndex}/${totalParts}${isLastPart ? ' (POSLEDN√Å)' : ''} (ZAƒåIATOK) =====\n\n`;
        const footer = `\n// ===== ${filePath} - ƒåAS≈§ ${partIndex}/${totalParts}${isLastPart ? ' (POSLEDN√Å)' : ''} (KONIEC) =====\n`;

        parts.push(header + currentPart + footer);
    }

    // Aktualizujeme poƒçet ƒçast√≠ v hlaviƒçk√°ch
    const actualTotalParts = parts.length;
    return parts.map((part, index) => {
        const partNum = index + 1;
        const isLast = partNum === actualTotalParts;
        const lastLabel = isLast ? ' (POSLEDN√Å)' : '';

        // Nahrad√≠me nespr√°vne poƒçty spr√°vnymi
        return part
            .replace(/ƒåAS≈§ \d+\/\d+/g, `ƒåAS≈§ ${partNum}/${actualTotalParts}`)
            .replace(/\(POSLEDN√Å\)/g, '')
            .replace(/(ƒåAS≈§ \d+\/\d+)( \(ZAƒåIATOK\))/g, `$1${lastLabel}$2`)
            .replace(/(ƒåAS≈§ \d+\/\d+)( \(KONIEC\))/g, `$1${lastLabel}$2`);
    });
}

// Funkcia na generovanie obsahu v√Ωstupn√©ho s√∫boru
async function generateFileContent(root) {
    let content = '';
    
    async function processNode(node) {
        if (node.type === 'file' && node.selected) {
            try {
                // Naƒç√≠tanie obsahu s√∫boru
                const fileHandle = node.handle;
                const file = await fileHandle.getFile();
                
                // Kontrola veƒækosti s√∫boru
                if (file.size > config.maxFileSize) {
                    content += config.outputSeparator.replace('{{filePath}}', node.path);
                    content += `// S√∫bor je pr√≠li≈° veƒæk√Ω (${formatFileSize(file.size)}), prekraƒçuje limit ${formatFileSize(config.maxFileSize)}\n`;
                } else {
                    // Preƒç√≠tanie obsahu s√∫boru
                    const text = await readFileAsText(file);
                    
                    // Pridanie s√∫boru do v√Ωstupu
                    content += config.outputSeparator.replace('{{filePath}}', node.path);
                    content += text;
                }
            } catch (error) {
                console.error(`Chyba pri ƒç√≠tan√≠ s√∫boru ${node.path}:`, error);
                content += config.outputSeparator.replace('{{filePath}}', node.path);
                content += `// Chyba pri ƒç√≠tan√≠ s√∫boru: ${error.message}\n`;
            }
        } else if (node.type === 'directory') {
            // Rekurz√≠vne spracovanie vybran√Ωch podadres√°rov a s√∫borov
            for (const child of node.children) {
                if (child.selected === true || child.selected === null) {
                    await processNode(child);
                }
            }
        }
    }
    
    await processNode(root);
    
    return content;
}

// Funkcia na ƒç√≠tanie s√∫boru ako text
async function readFileAsText(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (event) => resolve(event.target.result);
        reader.onerror = (event) => reject(new Error('Chyba pri ƒç√≠tan√≠ s√∫boru'));
        reader.readAsText(file, 'UTF-8');
    });
}

// Pomocn√° funkcia na form√°tovanie veƒækosti s√∫boru
function formatFileSize(bytes) {
    if (bytes < 1024) return bytes + ' B';
    if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
    return (bytes / 1048576).toFixed(1) + ' MB';
}

// Funkcia na zobrazenie chybovej spr√°vy
function showError(message) {
    statusEl.textContent = message;
    statusEl.className = 'status error';
}

// Funkcia na zobrazenie stavovej spr√°vy
function showStatus(message, type = '') {
    statusEl.textContent = message;
    statusEl.className = type ? `status ${type}` : 'status';
}
//]]>
</script>
</html>