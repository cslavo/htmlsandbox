<html><head><base href="https://infinite-craft.websim" />
<title>Infinite Craft</title>
<style>
  body, html {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    font-family: 'Roboto', Arial, sans-serif;
    background-color: #f0f8ff;
  }
  #game-area {
    width: 100vw;
    height: 100vh;
    position: relative;
    overflow: hidden;
    background: linear-gradient(120deg, #e0f7fa, #f3e5f5);
    animation: gradientBG 15s ease infinite;
  }
  @keyframes gradientBG {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
  }
  .word-block {
    height: 40px;
    background-color: rgba(255, 255, 255, 0.9);
    border: none;
    border-radius: 20px;
    position: absolute;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: move;
    user-select: none;
    font-size: 16px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1), 0 1px 3px rgba(0,0,0,0.08);
    transition: transform 0.1s, box-shadow 0.1s;
    padding: 0 20px;
    white-space: nowrap;
    will-change: transform;
  }
  .word-block:hover {
    transform: translateY(-2px);
    box-shadow: 0 7px 14px rgba(0,0,0,0.1), 0 3px 6px rgba(0,0,0,0.08);
  }
  .word-block:active {
    transform: translateY(1px);
  }
  .combined {
    animation: combinePulse 0.3s cubic-bezier(0.4, 0, 0.6, 1);
  }
  @keyframes combinePulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); background-color: rgba(160, 230, 255, 0.9); }
  }
  #discovery-log {
    position: fixed;
    top: 20px;
    right: 20px;
    width: 250px;
    height: auto;
    max-height: 80vh;
    overflow-y: auto;
    background-color: rgba(255, 255, 255, 0.9);
    border: none;
    border-radius: 15px;
    padding: 20px;
    font-size: 14px;
    box-shadow: 0 10px 20px rgba(0,0,0,0.1), 0 6px 6px rgba(0,0,0,0.1);
  }
  #discovery-search {
    width: 100%;
    padding: 8px;
    margin-bottom: 10px;
    border: 1px solid #ddd;
    border-radius: 5px;
    font-size: 14px;
  }
  .discovery-item {
    margin-bottom: 10px;
    cursor: move;
    padding: 10px;
    border: none;
    border-radius: 10px;
    background-color: #f0f0f0;
    transition: all 0.3s ease;
  }
  .discovery-item:hover {
    background-color: #e0e0e0;
    transform: translateX(-5px);
  }
  .combining-animation {
    position: absolute;
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background: radial-gradient(circle, rgba(52, 152, 219, 0.8) 0%, rgba(52, 152, 219, 0) 70%);
    animation: combineScale 0.3s ease-out;
    z-index: 1000;
    opacity: 0.6;
  }
  @keyframes combineScale {
    0% { transform: scale(0); opacity: 0; }
    50% { transform: scale(1.1); opacity: 0.8; }
    100% { transform: scale(1); opacity: 0.6; }
  }
  .floating-particle {
    position: absolute;
    width: 10px;
    height: 10px;
    background-color: rgba(255, 255, 255, 0.6);
    border-radius: 50%;
    pointer-events: none;
    animation: float 15s infinite ease-in-out;
  }
  @keyframes float {
    0%, 100% { transform: translate(0, 0); }
    25% { transform: translate(50px, 50px); }
    50% { transform: translate(100px, -50px); }
    75% { transform: translate(-50px, 100px); }
  }
  #reset-button {
    position: fixed;
    bottom: 20px;
    right: 20px;
    padding: 10px 20px;
    background-color: #f44336;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    transition: background-color 0.3s;
  }
  #reset-button:hover {
    background-color: #d32f2f;
  }
  #menu-toggle {
    position: fixed;
    top: 20px;
    left: 20px;
    z-index: 1001;
    background: none;
    border: none;
    cursor: pointer;
    padding: 10px;
  }
  .burger-icon {
    display: block;
    width: 30px;
    height: 3px;
    background-color: #333;
    margin: 6px 0;
    transition: 0.4s;
  }
  #menu {
    position: fixed;
    top: 0;
    left: -300px;
    width: 300px;
    height: 100%;
    background-color: rgba(255, 255, 255, 0.95);
    transition: 0.3s;
    padding: 60px 20px 20px;
    box-sizing: border-box;
    overflow-y: auto;
    z-index: 1000;
  }
  #menu.open {
    left: 0;
  }
  #menu h2 {
    margin-top: 0;
  }
  #menu p {
    margin-bottom: 15px;
  }
</style>
</head>
<body>
<div id="game-area"></div>
<div id="discovery-log">
  <input type="text" id="discovery-search" placeholder="Search discoveries...">
  <div id="discovery-items"></div>
</div>
<button id="reset-button">Reset Game</button>

<button id="menu-toggle">
  <span class="burger-icon"></span>
  <span class="burger-icon"></span>
  <span class="burger-icon"></span>
</button>

<div id="menu">
  <h2>How to Play Infinite Craft</h2>
  <p>Welcome to Infinite Craft, a creative word combination game! Here's how to play:</p>
  <ol>
    <li>Start with the four basic elements: Water, Fire, Wind, and Earth.</li>
    <li>Drag and drop two elements or words together to combine them.</li>
    <li>Discover new elements and words through these combinations.</li>
    <li>Your discoveries are logged on the right side of the screen.</li>
    <li>Double-click a word to duplicate it.</li>
    <li>Right-click a word to delete it.</li>
    <li>Keep combining to unlock more complex items and concepts!</li>
  </ol>
  <h3>API Information</h3>
  <p>Craft API Response Format:</p>
  <pre>{
  "result": "New Word",
  "emoji": "üÜï"
}</pre>
  <p>Get Emoji API Response Format:</p>
  <pre>{
  "emoji": "üÜï"
}</pre>
</div>

<script>
const gameArea = document.getElementById('game-area');
const discoveryLog = document.getElementById('discovery-items');
const discoverySearch = document.getElementById('discovery-search');
const resetButton = document.getElementById('reset-button');
const menuToggle = document.getElementById('menu-toggle');
const menu = document.getElementById('menu');
let draggingElement = null;
let offset = { x: 0, y: 0 };

const initialWords = [
  { word: 'Water', emoji: 'üíß' },
  { word: 'Fire', emoji: 'üî•' },
  { word: 'Wind', emoji: 'üí®' },
  { word: 'Earth', emoji: 'üåé' }
];
let discoveries = new Map();

let zIndex = 1;

function createWordBlock(wordObj, x, y) {
  console.log(`Creating word block: ${wordObj.word}`);
  const block = document.createElement('div');
  block.className = 'word-block';
  block.textContent = `${wordObj.emoji} ${wordObj.word}`;
  if (x === undefined || y === undefined) {
    block.style.left = `${Math.random() * (gameArea.clientWidth - 150)}px`;
    block.style.top = `${Math.random() * (gameArea.clientHeight - 40)}px`;
  } else {
    block.style.left = `${x}px`;
    block.style.top = `${y}px`;
  }
  block.style.zIndex = zIndex++;
  gameArea.appendChild(block);

  // Adjust width to fit content
  block.style.width = 'auto';

  block.addEventListener('mousedown', startDragging);
  block.addEventListener('touchstart', startDragging, { passive: false });
  block.addEventListener('contextmenu', deleteBlock);
  block.addEventListener('dblclick', duplicateBlock);
  console.log(`Word block created: ${wordObj.word} at (${block.style.left}, ${block.style.top})`);
}

function startDragging(e) {
  e.preventDefault();
  draggingElement = e.target.closest('.word-block') || e.target;
  console.log(`Started dragging: ${draggingElement.textContent}`);
  draggingElement.style.zIndex = zIndex++;
  const clientX = e.clientX || e.touches[0].clientX;
  const clientY = e.clientY || e.touches[0].clientY;
  
  if (draggingElement.classList.contains('discovery-item')) {
    // Create a new word block when dragging from discovery
    const [emoji, ...wordParts] = draggingElement.textContent.split(' ');
    const word = wordParts.join(' ');
    createWordBlock({ word, emoji }, clientX, clientY);
    draggingElement = document.querySelector(`.word-block[style*="left: ${clientX}px"][style*="top: ${clientY}px"]`);
  }
  
  const rect = draggingElement.getBoundingClientRect();
  offset.x = clientX - rect.left;
  offset.y = clientY - rect.top;
  
  document.addEventListener('mousemove', drag);
  document.addEventListener('touchmove', drag, { passive: false });
  document.addEventListener('mouseup', stopDragging);
  document.addEventListener('touchend', stopDragging);
}

function drag(e) {
  if (!draggingElement) return;
  e.preventDefault();
  const clientX = e.clientX || e.touches[0].clientX;
  const clientY = e.clientY || e.touches[0].clientY;
  
  // Use requestAnimationFrame for smoother dragging
  requestAnimationFrame(() => {
    draggingElement.style.left = `${clientX - offset.x}px`;
    draggingElement.style.top = `${clientY - offset.y}px`;
  });
}

function stopDragging(e) {
  if (draggingElement) {
    console.log(`Stopped dragging: ${draggingElement.textContent}`);
    checkCollision();
    draggingElement = null;
  }
  document.removeEventListener('mousemove', drag);
  document.removeEventListener('touchmove', drag);
  document.removeEventListener('mouseup', stopDragging);
  document.removeEventListener('touchend', stopDragging);
}

function deleteBlock(e) {
  e.preventDefault();
  console.log(`Deleting block: ${e.target.textContent}`);
  e.target.remove();
}

function duplicateBlock(e) {
  console.log(`Duplicating block: ${e.target.textContent}`);
  const rect = e.target.getBoundingClientRect();
  const newX = rect.left + 20;
  const newY = rect.top + 20;
  const [emoji, ...wordParts] = e.target.textContent.split(' ');
  const word = wordParts.join(' ');
  createWordBlock({ word, emoji }, newX, newY);
}

function checkCollision() {
  console.log('Checking collisions');
  const blocks = document.querySelectorAll('.word-block');
  blocks.forEach(block => {
    if (block !== draggingElement && isColliding(draggingElement, block)) {
      console.log(`Collision detected between ${draggingElement.textContent} and ${block.textContent}`);
      combineWords(draggingElement, block);
    }
  });
}

function isColliding(el1, el2) {
  const rect1 = el1.getBoundingClientRect();
  const rect2 = el2.getBoundingClientRect();
  return !(rect1.right < rect2.left || 
           rect1.left > rect2.right || 
           rect1.bottom < rect2.top || 
           rect1.top > rect2.bottom);
}

async function combineWords(block1, block2) {
  const [emoji1, ...word1Parts] = block1.textContent.split(' ');
  const [emoji2, ...word2Parts] = block2.textContent.split(' ');
  const word1 = word1Parts.join(' ');
  const word2 = word2Parts.join(' ');
  console.log(`Attempting to combine words: ${word1} + ${word2}`);
  
  const x = (parseInt(block1.style.left) + parseInt(block2.style.left)) / 2;
  const y = (parseInt(block1.style.top) + parseInt(block2.style.top)) / 2;
  
  // Create and show combining animation
  const animation = document.createElement('div');
  animation.className = 'combining-animation';
  animation.style.left = `${x - 40}px`;
  animation.style.top = `${y - 40}px`;
  gameArea.appendChild(animation);
  
  try {
    let result = await fetchCombination(word1, word2);
    
    if (result && result.result !== 'Nothing') {
      const newWord = result.result;
      let newEmoji = result.emoji;
      
      if (!newEmoji) {
        newEmoji = await fetchEmoji(newWord);
      }
      
      if (!discoveries.has(newWord)) {
        discoveries.set(newWord, { word: newWord, emoji: newEmoji });
        updateDiscoveryLog({ word: newWord, emoji: newEmoji });
        saveDiscoveries();
        console.log(`New discovery: ${newWord}`);
      }
      
      createWordBlock({ word:newWord, emoji: newEmoji }, x, y);
      const newBlock = document.querySelector(`.word-block[style*="left: ${x}px"][style*="top: ${y}px"]`);
      newBlock.classList.add('combined');
      setTimeout(() => newBlock.classList.remove('combined'), 300);
    } else {
      console.log('Combination resulted in Nothing or invalid result');
    }
  } catch (error) {
    console.error('Error combining words:', error);
  } finally {
    // Remove combining animation
    setTimeout(() => animation.remove(), 300);
    
    // Delete the original word blocks
    block1.remove();
    block2.remove();
  }
}

async function fetchCombination(word1, word2, retries = 3) {
  while (retries > 0) {
    try {
      const response = await fetch('/api/craft', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Response-Format': '{"result": "string", "emoji": "string"}'
        },
        body: JSON.stringify({
          equation: `(${word1}) + (${word2}) = ?`,
          result: ''
        }),
      });
      
      if (!response.ok) {
        throw new Error('API request failed');
      }
      
      const result = await response.json();
      console.log(`API returned result:`, result);
      
      if (result && result.result && result.result !== '[object Object]') {
        return result;
      }
      
      console.log(`Invalid result, retrying... (${retries} attempts left)`);
      retries--;
    } catch (error) {
      console.error('Error fetching combination:', error);
      retries--;
      if (retries === 0) throw error;
    }
  }
  throw new Error('Max retries reached');
}

async function fetchEmoji(word) {
  try {
    const response = await fetch(`/api/emoji?word=${encodeURIComponent(word)}`, {
      headers: {
        'X-Response-Format': '{"emoji": "string"}'
      }
    });
    if (!response.ok) {
      throw new Error('Emoji API request failed');
    }
    const result = await response.json();
    return result.emoji || '‚ùì';
  } catch (error) {
    console.error('Error fetching emoji:', error);
    return '‚ùì';
  }
}

function updateDiscoveryLog(wordObj) {
  console.log(`Updating discovery log: ${wordObj.word}`);
  const discoveryItem = document.createElement('div');
  discoveryItem.className = 'discovery-item';
  discoveryItem.textContent = `${wordObj.emoji} ${wordObj.word}`;
  discoveryItem.draggable = true;
  discoveryItem.addEventListener('mousedown', startDragging);
  discoveryItem.addEventListener('touchstart', startDragging, { passive: false });
  discoveryLog.appendChild(discoveryItem);
}

function createFloatingParticles() {
  for (let i = 0; i < 20; i++) {
    const particle = document.createElement('div');
    particle.className = 'floating-particle';
    particle.style.left = `${Math.random() * 100}%`;
    particle.style.top = `${Math.random() * 100}%`;
    particle.style.animationDelay = `${Math.random() * 15}s`;
    gameArea.appendChild(particle);
  }
}

function saveDiscoveries() {
  localStorage.setItem('discoveries', JSON.stringify(Array.from(discoveries.entries())));
}

function loadDiscoveries() {
  const savedDiscoveries = localStorage.getItem('discoveries');
  if (savedDiscoveries) {
    discoveries = new Map(JSON.parse(savedDiscoveries));
    discoveries.forEach(wordObj => {
      updateDiscoveryLog(wordObj);
    });
  }
}

function resetGame() {
  if (confirm('Are you sure you want to reset the game? This will clear all your discoveries.')) {
    localStorage.removeItem('discoveries');
    discoveries.clear();
    gameArea.innerHTML = '';
    discoveryLog.innerHTML = '';
    initializeGame();
  }
}

function initializeGame() {
  loadDiscoveries();
  initialWords.forEach(wordObj => {
    createWordBlock(wordObj);
    if (!discoveries.has(wordObj.word)) {
      discoveries.set(wordObj.word, wordObj);
      updateDiscoveryLog(wordObj);
    }
  });
  createFloatingParticles();
}

function filterDiscoveries() {
  const searchTerm = discoverySearch.value.toLowerCase();
  const discoveryItems = discoveryLog.getElementsByClassName('discovery-item');
  
  Array.from(discoveryItems).forEach(item => {
    const itemText = item.textContent.toLowerCase();
    if (itemText.includes(searchTerm)) {
      item.style.display = '';
    } else {
      item.style.display = 'none';
    }
  });
}

// Initialize the game
initializeGame();

// Event listeners
discoverySearch.addEventListener('input', filterDiscoveries);
resetButton.addEventListener('click', resetGame);
menuToggle.addEventListener('click', () => {
  menu.classList.toggle('open');
});

// Resize handler
window.addEventListener('resize', () => {
  console.log('Window resized, adjusting block positions');
  const blocks = document.querySelectorAll('.word-block');
  blocks.forEach(block => {
    const maxX = gameArea.clientWidth - block.offsetWidth;
    const maxY = gameArea.clientHeight - block.offsetHeight;
    block.style.left = `${Math.min(parseInt(block.style.left), maxX)}px`;
    block.style.top = `${Math.min(parseInt(block.style.top), maxY)}px`;
  });
});

// Prevent text selection during drag
gameArea.addEventListener('selectstart', (e) => {
  if (draggingElement) {
    e.preventDefault();
  }
});

// Optimize performance for mobile devices
let lastTime = 0;
const fps = 60;
const interval = 1000 / fps;

function optimizedDrag(e) {
  const currentTime = performance.now();
  if (currentTime - lastTime < interval) return;
  
  lastTime = currentTime;
  drag(e);
}

// Replace drag event listener with optimized version
document.addEventListener('mousemove', optimizedDrag);
document.addEventListener('touchmove', optimizedDrag, { passive: false });

// Add pinch-to-zoom functionality for mobile devices
let initialDistance = 0;
let currentScale = 1;

gameArea.addEventListener('touchstart', (e) => {
  if (e.touches.length === 2) {
    initialDistance = getDistance(e.touches[0], e.touches[1]);
  }
});

gameArea.addEventListener('touchmove', (e) => {
  if (e.touches.length === 2) {
    const currentDistance = getDistance(e.touches[0], e.touches[1]);
    const scale = currentDistance / initialDistance;
    
    if (Math.abs(scale - 1) > 0.1) {
      currentScale *= scale;
      currentScale = Math.min(Math.max(currentScale, 0.5), 2);
      gameArea.style.transform = `scale(${currentScale})`;
    }
  }
});

function getDistance(touch1, touch2) {
  const dx = touch1.clientX - touch2.clientX;
  const dy = touch1.clientY - touch2.clientY;
  return Math.sqrt(dx * dx + dy * dy);
}

console.log('Game initialization complete');
</script>
</body></html>